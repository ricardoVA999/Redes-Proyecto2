// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocol.proto

#ifndef PROTOBUF_INCLUDED_protocol_2eproto
#define PROTOBUF_INCLUDED_protocol_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_protocol_2eproto 

namespace protobuf_protocol_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_protocol_2eproto
namespace protocol {
class ClientConnect;
class ClientConnectDefaultTypeInternal;
extern ClientConnectDefaultTypeInternal _ClientConnect_default_instance_;
class ClientMessage;
class ClientMessageDefaultTypeInternal;
extern ClientMessageDefaultTypeInternal _ClientMessage_default_instance_;
class ErrorResponse;
class ErrorResponseDefaultTypeInternal;
extern ErrorResponseDefaultTypeInternal _ErrorResponse_default_instance_;
class RoomsToJoin;
class RoomsToJoinDefaultTypeInternal;
extern RoomsToJoinDefaultTypeInternal _RoomsToJoin_default_instance_;
class ServerMessage;
class ServerMessageDefaultTypeInternal;
extern ServerMessageDefaultTypeInternal _ServerMessage_default_instance_;
}  // namespace protocol
namespace google {
namespace protobuf {
template<> ::protocol::ClientConnect* Arena::CreateMaybeMessage<::protocol::ClientConnect>(Arena*);
template<> ::protocol::ClientMessage* Arena::CreateMaybeMessage<::protocol::ClientMessage>(Arena*);
template<> ::protocol::ErrorResponse* Arena::CreateMaybeMessage<::protocol::ErrorResponse>(Arena*);
template<> ::protocol::RoomsToJoin* Arena::CreateMaybeMessage<::protocol::RoomsToJoin>(Arena*);
template<> ::protocol::ServerMessage* Arena::CreateMaybeMessage<::protocol::ServerMessage>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace protocol {

// ===================================================================

class ClientConnect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.ClientConnect) */ {
 public:
  ClientConnect();
  virtual ~ClientConnect();

  ClientConnect(const ClientConnect& from);

  inline ClientConnect& operator=(const ClientConnect& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientConnect(ClientConnect&& from) noexcept
    : ClientConnect() {
    *this = ::std::move(from);
  }

  inline ClientConnect& operator=(ClientConnect&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientConnect& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientConnect* internal_default_instance() {
    return reinterpret_cast<const ClientConnect*>(
               &_ClientConnect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ClientConnect* other);
  friend void swap(ClientConnect& a, ClientConnect& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientConnect* New() const final {
    return CreateMaybeMessage<ClientConnect>(NULL);
  }

  ClientConnect* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientConnect>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientConnect& from);
  void MergeFrom(const ClientConnect& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientConnect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string username = 1;
  bool has_username() const;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional string ip = 2;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 2;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // @@protoc_insertion_point(class_scope:protocol.ClientConnect)
 private:
  void set_has_username();
  void clear_has_username();
  void set_has_ip();
  void clear_has_ip();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoomsToJoin : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.RoomsToJoin) */ {
 public:
  RoomsToJoin();
  virtual ~RoomsToJoin();

  RoomsToJoin(const RoomsToJoin& from);

  inline RoomsToJoin& operator=(const RoomsToJoin& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoomsToJoin(RoomsToJoin&& from) noexcept
    : RoomsToJoin() {
    *this = ::std::move(from);
  }

  inline RoomsToJoin& operator=(RoomsToJoin&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomsToJoin& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoomsToJoin* internal_default_instance() {
    return reinterpret_cast<const RoomsToJoin*>(
               &_RoomsToJoin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RoomsToJoin* other);
  friend void swap(RoomsToJoin& a, RoomsToJoin& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoomsToJoin* New() const final {
    return CreateMaybeMessage<RoomsToJoin>(NULL);
  }

  RoomsToJoin* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoomsToJoin>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoomsToJoin& from);
  void MergeFrom(const RoomsToJoin& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomsToJoin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string rooms = 1;
  bool has_rooms() const;
  void clear_rooms();
  static const int kRoomsFieldNumber = 1;
  const ::std::string& rooms() const;
  void set_rooms(const ::std::string& value);
  #if LANG_CXX11
  void set_rooms(::std::string&& value);
  #endif
  void set_rooms(const char* value);
  void set_rooms(const char* value, size_t size);
  ::std::string* mutable_rooms();
  ::std::string* release_rooms();
  void set_allocated_rooms(::std::string* rooms);

  // @@protoc_insertion_point(class_scope:protocol.RoomsToJoin)
 private:
  void set_has_rooms();
  void clear_has_rooms();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr rooms_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.ClientMessage) */ {
 public:
  ClientMessage();
  virtual ~ClientMessage();

  ClientMessage(const ClientMessage& from);

  inline ClientMessage& operator=(const ClientMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientMessage(ClientMessage&& from) noexcept
    : ClientMessage() {
    *this = ::std::move(from);
  }

  inline ClientMessage& operator=(ClientMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientMessage* internal_default_instance() {
    return reinterpret_cast<const ClientMessage*>(
               &_ClientMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ClientMessage* other);
  friend void swap(ClientMessage& a, ClientMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientMessage* New() const final {
    return CreateMaybeMessage<ClientMessage>(NULL);
  }

  ClientMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientMessage& from);
  void MergeFrom(const ClientMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protocol.ClientConnect connect = 3;
  bool has_connect() const;
  void clear_connect();
  static const int kConnectFieldNumber = 3;
  private:
  const ::protocol::ClientConnect& _internal_connect() const;
  public:
  const ::protocol::ClientConnect& connect() const;
  ::protocol::ClientConnect* release_connect();
  ::protocol::ClientConnect* mutable_connect();
  void set_allocated_connect(::protocol::ClientConnect* connect);

  // required int32 option = 1;
  bool has_option() const;
  void clear_option();
  static const int kOptionFieldNumber = 1;
  ::google::protobuf::int32 option() const;
  void set_option(::google::protobuf::int32 value);

  // optional int32 userId = 2;
  bool has_userid() const;
  void clear_userid();
  static const int kUserIdFieldNumber = 2;
  ::google::protobuf::int32 userid() const;
  void set_userid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.ClientMessage)
 private:
  void set_has_option();
  void clear_has_option();
  void set_has_userid();
  void clear_has_userid();
  void set_has_connect();
  void clear_has_connect();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::protocol::ClientConnect* connect_;
  ::google::protobuf::int32 option_;
  ::google::protobuf::int32 userid_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServerMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.ServerMessage) */ {
 public:
  ServerMessage();
  virtual ~ServerMessage();

  ServerMessage(const ServerMessage& from);

  inline ServerMessage& operator=(const ServerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerMessage(ServerMessage&& from) noexcept
    : ServerMessage() {
    *this = ::std::move(from);
  }

  inline ServerMessage& operator=(ServerMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerMessage* internal_default_instance() {
    return reinterpret_cast<const ServerMessage*>(
               &_ServerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ServerMessage* other);
  friend void swap(ServerMessage& a, ServerMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerMessage* New() const final {
    return CreateMaybeMessage<ServerMessage>(NULL);
  }

  ServerMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServerMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServerMessage& from);
  void MergeFrom(const ServerMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protocol.RoomsToJoin rooms = 2;
  bool has_rooms() const;
  void clear_rooms();
  static const int kRoomsFieldNumber = 2;
  private:
  const ::protocol::RoomsToJoin& _internal_rooms() const;
  public:
  const ::protocol::RoomsToJoin& rooms() const;
  ::protocol::RoomsToJoin* release_rooms();
  ::protocol::RoomsToJoin* mutable_rooms();
  void set_allocated_rooms(::protocol::RoomsToJoin* rooms);

  // required int32 option = 1;
  bool has_option() const;
  void clear_option();
  static const int kOptionFieldNumber = 1;
  ::google::protobuf::int32 option() const;
  void set_option(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.ServerMessage)
 private:
  void set_has_option();
  void clear_has_option();
  void set_has_rooms();
  void clear_has_rooms();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::protocol::RoomsToJoin* rooms_;
  ::google::protobuf::int32 option_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ErrorResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.ErrorResponse) */ {
 public:
  ErrorResponse();
  virtual ~ErrorResponse();

  ErrorResponse(const ErrorResponse& from);

  inline ErrorResponse& operator=(const ErrorResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ErrorResponse(ErrorResponse&& from) noexcept
    : ErrorResponse() {
    *this = ::std::move(from);
  }

  inline ErrorResponse& operator=(ErrorResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ErrorResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ErrorResponse* internal_default_instance() {
    return reinterpret_cast<const ErrorResponse*>(
               &_ErrorResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ErrorResponse* other);
  friend void swap(ErrorResponse& a, ErrorResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ErrorResponse* New() const final {
    return CreateMaybeMessage<ErrorResponse>(NULL);
  }

  ErrorResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ErrorResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ErrorResponse& from);
  void MergeFrom(const ErrorResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ErrorResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string errorMessage = 1;
  bool has_errormessage() const;
  void clear_errormessage();
  static const int kErrorMessageFieldNumber = 1;
  const ::std::string& errormessage() const;
  void set_errormessage(const ::std::string& value);
  #if LANG_CXX11
  void set_errormessage(::std::string&& value);
  #endif
  void set_errormessage(const char* value);
  void set_errormessage(const char* value, size_t size);
  ::std::string* mutable_errormessage();
  ::std::string* release_errormessage();
  void set_allocated_errormessage(::std::string* errormessage);

  // @@protoc_insertion_point(class_scope:protocol.ErrorResponse)
 private:
  void set_has_errormessage();
  void clear_has_errormessage();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr errormessage_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ClientConnect

// required string username = 1;
inline bool ClientConnect::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientConnect::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientConnect::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientConnect::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& ClientConnect::username() const {
  // @@protoc_insertion_point(field_get:protocol.ClientConnect.username)
  return username_.GetNoArena();
}
inline void ClientConnect::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.ClientConnect.username)
}
#if LANG_CXX11
inline void ClientConnect::set_username(::std::string&& value) {
  set_has_username();
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.ClientConnect.username)
}
#endif
inline void ClientConnect::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.ClientConnect.username)
}
inline void ClientConnect::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.ClientConnect.username)
}
inline ::std::string* ClientConnect::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:protocol.ClientConnect.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientConnect::release_username() {
  // @@protoc_insertion_point(field_release:protocol.ClientConnect.username)
  if (!has_username()) {
    return NULL;
  }
  clear_has_username();
  return username_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientConnect::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:protocol.ClientConnect.username)
}

// optional string ip = 2;
inline bool ClientConnect::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientConnect::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientConnect::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientConnect::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip();
}
inline const ::std::string& ClientConnect::ip() const {
  // @@protoc_insertion_point(field_get:protocol.ClientConnect.ip)
  return ip_.GetNoArena();
}
inline void ClientConnect::set_ip(const ::std::string& value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.ClientConnect.ip)
}
#if LANG_CXX11
inline void ClientConnect::set_ip(::std::string&& value) {
  set_has_ip();
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.ClientConnect.ip)
}
#endif
inline void ClientConnect::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.ClientConnect.ip)
}
inline void ClientConnect::set_ip(const char* value, size_t size) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.ClientConnect.ip)
}
inline ::std::string* ClientConnect::mutable_ip() {
  set_has_ip();
  // @@protoc_insertion_point(field_mutable:protocol.ClientConnect.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientConnect::release_ip() {
  // @@protoc_insertion_point(field_release:protocol.ClientConnect.ip)
  if (!has_ip()) {
    return NULL;
  }
  clear_has_ip();
  return ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientConnect::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    set_has_ip();
  } else {
    clear_has_ip();
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:protocol.ClientConnect.ip)
}

// -------------------------------------------------------------------

// RoomsToJoin

// required string rooms = 1;
inline bool RoomsToJoin::has_rooms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomsToJoin::set_has_rooms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomsToJoin::clear_has_rooms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomsToJoin::clear_rooms() {
  rooms_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_rooms();
}
inline const ::std::string& RoomsToJoin::rooms() const {
  // @@protoc_insertion_point(field_get:protocol.RoomsToJoin.rooms)
  return rooms_.GetNoArena();
}
inline void RoomsToJoin::set_rooms(const ::std::string& value) {
  set_has_rooms();
  rooms_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.RoomsToJoin.rooms)
}
#if LANG_CXX11
inline void RoomsToJoin::set_rooms(::std::string&& value) {
  set_has_rooms();
  rooms_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.RoomsToJoin.rooms)
}
#endif
inline void RoomsToJoin::set_rooms(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_rooms();
  rooms_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.RoomsToJoin.rooms)
}
inline void RoomsToJoin::set_rooms(const char* value, size_t size) {
  set_has_rooms();
  rooms_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.RoomsToJoin.rooms)
}
inline ::std::string* RoomsToJoin::mutable_rooms() {
  set_has_rooms();
  // @@protoc_insertion_point(field_mutable:protocol.RoomsToJoin.rooms)
  return rooms_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoomsToJoin::release_rooms() {
  // @@protoc_insertion_point(field_release:protocol.RoomsToJoin.rooms)
  if (!has_rooms()) {
    return NULL;
  }
  clear_has_rooms();
  return rooms_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoomsToJoin::set_allocated_rooms(::std::string* rooms) {
  if (rooms != NULL) {
    set_has_rooms();
  } else {
    clear_has_rooms();
  }
  rooms_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rooms);
  // @@protoc_insertion_point(field_set_allocated:protocol.RoomsToJoin.rooms)
}

// -------------------------------------------------------------------

// ClientMessage

// required int32 option = 1;
inline bool ClientMessage::has_option() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientMessage::set_has_option() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientMessage::clear_has_option() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientMessage::clear_option() {
  option_ = 0;
  clear_has_option();
}
inline ::google::protobuf::int32 ClientMessage::option() const {
  // @@protoc_insertion_point(field_get:protocol.ClientMessage.option)
  return option_;
}
inline void ClientMessage::set_option(::google::protobuf::int32 value) {
  set_has_option();
  option_ = value;
  // @@protoc_insertion_point(field_set:protocol.ClientMessage.option)
}

// optional int32 userId = 2;
inline bool ClientMessage::has_userid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientMessage::set_has_userid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientMessage::clear_has_userid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientMessage::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 ClientMessage::userid() const {
  // @@protoc_insertion_point(field_get:protocol.ClientMessage.userId)
  return userid_;
}
inline void ClientMessage::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:protocol.ClientMessage.userId)
}

// optional .protocol.ClientConnect connect = 3;
inline bool ClientMessage::has_connect() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientMessage::set_has_connect() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientMessage::clear_has_connect() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientMessage::clear_connect() {
  if (connect_ != NULL) connect_->Clear();
  clear_has_connect();
}
inline const ::protocol::ClientConnect& ClientMessage::_internal_connect() const {
  return *connect_;
}
inline const ::protocol::ClientConnect& ClientMessage::connect() const {
  const ::protocol::ClientConnect* p = connect_;
  // @@protoc_insertion_point(field_get:protocol.ClientMessage.connect)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::ClientConnect*>(
      &::protocol::_ClientConnect_default_instance_);
}
inline ::protocol::ClientConnect* ClientMessage::release_connect() {
  // @@protoc_insertion_point(field_release:protocol.ClientMessage.connect)
  clear_has_connect();
  ::protocol::ClientConnect* temp = connect_;
  connect_ = NULL;
  return temp;
}
inline ::protocol::ClientConnect* ClientMessage::mutable_connect() {
  set_has_connect();
  if (connect_ == NULL) {
    auto* p = CreateMaybeMessage<::protocol::ClientConnect>(GetArenaNoVirtual());
    connect_ = p;
  }
  // @@protoc_insertion_point(field_mutable:protocol.ClientMessage.connect)
  return connect_;
}
inline void ClientMessage::set_allocated_connect(::protocol::ClientConnect* connect) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete connect_;
  }
  if (connect) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      connect = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, connect, submessage_arena);
    }
    set_has_connect();
  } else {
    clear_has_connect();
  }
  connect_ = connect;
  // @@protoc_insertion_point(field_set_allocated:protocol.ClientMessage.connect)
}

// -------------------------------------------------------------------

// ServerMessage

// required int32 option = 1;
inline bool ServerMessage::has_option() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerMessage::set_has_option() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerMessage::clear_has_option() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerMessage::clear_option() {
  option_ = 0;
  clear_has_option();
}
inline ::google::protobuf::int32 ServerMessage::option() const {
  // @@protoc_insertion_point(field_get:protocol.ServerMessage.option)
  return option_;
}
inline void ServerMessage::set_option(::google::protobuf::int32 value) {
  set_has_option();
  option_ = value;
  // @@protoc_insertion_point(field_set:protocol.ServerMessage.option)
}

// optional .protocol.RoomsToJoin rooms = 2;
inline bool ServerMessage::has_rooms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerMessage::set_has_rooms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerMessage::clear_has_rooms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerMessage::clear_rooms() {
  if (rooms_ != NULL) rooms_->Clear();
  clear_has_rooms();
}
inline const ::protocol::RoomsToJoin& ServerMessage::_internal_rooms() const {
  return *rooms_;
}
inline const ::protocol::RoomsToJoin& ServerMessage::rooms() const {
  const ::protocol::RoomsToJoin* p = rooms_;
  // @@protoc_insertion_point(field_get:protocol.ServerMessage.rooms)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::RoomsToJoin*>(
      &::protocol::_RoomsToJoin_default_instance_);
}
inline ::protocol::RoomsToJoin* ServerMessage::release_rooms() {
  // @@protoc_insertion_point(field_release:protocol.ServerMessage.rooms)
  clear_has_rooms();
  ::protocol::RoomsToJoin* temp = rooms_;
  rooms_ = NULL;
  return temp;
}
inline ::protocol::RoomsToJoin* ServerMessage::mutable_rooms() {
  set_has_rooms();
  if (rooms_ == NULL) {
    auto* p = CreateMaybeMessage<::protocol::RoomsToJoin>(GetArenaNoVirtual());
    rooms_ = p;
  }
  // @@protoc_insertion_point(field_mutable:protocol.ServerMessage.rooms)
  return rooms_;
}
inline void ServerMessage::set_allocated_rooms(::protocol::RoomsToJoin* rooms) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rooms_;
  }
  if (rooms) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rooms = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rooms, submessage_arena);
    }
    set_has_rooms();
  } else {
    clear_has_rooms();
  }
  rooms_ = rooms;
  // @@protoc_insertion_point(field_set_allocated:protocol.ServerMessage.rooms)
}

// -------------------------------------------------------------------

// ErrorResponse

// required string errorMessage = 1;
inline bool ErrorResponse::has_errormessage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ErrorResponse::set_has_errormessage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ErrorResponse::clear_has_errormessage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ErrorResponse::clear_errormessage() {
  errormessage_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_errormessage();
}
inline const ::std::string& ErrorResponse::errormessage() const {
  // @@protoc_insertion_point(field_get:protocol.ErrorResponse.errorMessage)
  return errormessage_.GetNoArena();
}
inline void ErrorResponse::set_errormessage(const ::std::string& value) {
  set_has_errormessage();
  errormessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.ErrorResponse.errorMessage)
}
#if LANG_CXX11
inline void ErrorResponse::set_errormessage(::std::string&& value) {
  set_has_errormessage();
  errormessage_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.ErrorResponse.errorMessage)
}
#endif
inline void ErrorResponse::set_errormessage(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_errormessage();
  errormessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.ErrorResponse.errorMessage)
}
inline void ErrorResponse::set_errormessage(const char* value, size_t size) {
  set_has_errormessage();
  errormessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.ErrorResponse.errorMessage)
}
inline ::std::string* ErrorResponse::mutable_errormessage() {
  set_has_errormessage();
  // @@protoc_insertion_point(field_mutable:protocol.ErrorResponse.errorMessage)
  return errormessage_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ErrorResponse::release_errormessage() {
  // @@protoc_insertion_point(field_release:protocol.ErrorResponse.errorMessage)
  if (!has_errormessage()) {
    return NULL;
  }
  clear_has_errormessage();
  return errormessage_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ErrorResponse::set_allocated_errormessage(::std::string* errormessage) {
  if (errormessage != NULL) {
    set_has_errormessage();
  } else {
    clear_has_errormessage();
  }
  errormessage_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), errormessage);
  // @@protoc_insertion_point(field_set_allocated:protocol.ErrorResponse.errorMessage)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_protocol_2eproto
