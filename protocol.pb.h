// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocol.proto

#ifndef PROTOBUF_INCLUDED_protocol_2eproto
#define PROTOBUF_INCLUDED_protocol_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_protocol_2eproto 

namespace protobuf_protocol_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[11];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_protocol_2eproto
namespace protocol {
class ClientConnect;
class ClientConnectDefaultTypeInternal;
extern ClientConnectDefaultTypeInternal _ClientConnect_default_instance_;
class ClientMessage;
class ClientMessageDefaultTypeInternal;
extern ClientMessageDefaultTypeInternal _ClientMessage_default_instance_;
class ErrorResponse;
class ErrorResponseDefaultTypeInternal;
extern ErrorResponseDefaultTypeInternal _ErrorResponse_default_instance_;
class JoinRoom;
class JoinRoomDefaultTypeInternal;
extern JoinRoomDefaultTypeInternal _JoinRoom_default_instance_;
class MatchStart;
class MatchStartDefaultTypeInternal;
extern MatchStartDefaultTypeInternal _MatchStart_default_instance_;
class NewTurn;
class NewTurnDefaultTypeInternal;
extern NewTurnDefaultTypeInternal _NewTurn_default_instance_;
class Notification;
class NotificationDefaultTypeInternal;
extern NotificationDefaultTypeInternal _Notification_default_instance_;
class RoomMessage;
class RoomMessageDefaultTypeInternal;
extern RoomMessageDefaultTypeInternal _RoomMessage_default_instance_;
class RoomsToJoin;
class RoomsToJoinDefaultTypeInternal;
extern RoomsToJoinDefaultTypeInternal _RoomsToJoin_default_instance_;
class SendCard;
class SendCardDefaultTypeInternal;
extern SendCardDefaultTypeInternal _SendCard_default_instance_;
class ServerMessage;
class ServerMessageDefaultTypeInternal;
extern ServerMessageDefaultTypeInternal _ServerMessage_default_instance_;
}  // namespace protocol
namespace google {
namespace protobuf {
template<> ::protocol::ClientConnect* Arena::CreateMaybeMessage<::protocol::ClientConnect>(Arena*);
template<> ::protocol::ClientMessage* Arena::CreateMaybeMessage<::protocol::ClientMessage>(Arena*);
template<> ::protocol::ErrorResponse* Arena::CreateMaybeMessage<::protocol::ErrorResponse>(Arena*);
template<> ::protocol::JoinRoom* Arena::CreateMaybeMessage<::protocol::JoinRoom>(Arena*);
template<> ::protocol::MatchStart* Arena::CreateMaybeMessage<::protocol::MatchStart>(Arena*);
template<> ::protocol::NewTurn* Arena::CreateMaybeMessage<::protocol::NewTurn>(Arena*);
template<> ::protocol::Notification* Arena::CreateMaybeMessage<::protocol::Notification>(Arena*);
template<> ::protocol::RoomMessage* Arena::CreateMaybeMessage<::protocol::RoomMessage>(Arena*);
template<> ::protocol::RoomsToJoin* Arena::CreateMaybeMessage<::protocol::RoomsToJoin>(Arena*);
template<> ::protocol::SendCard* Arena::CreateMaybeMessage<::protocol::SendCard>(Arena*);
template<> ::protocol::ServerMessage* Arena::CreateMaybeMessage<::protocol::ServerMessage>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace protocol {

// ===================================================================

class ClientConnect : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.ClientConnect) */ {
 public:
  ClientConnect();
  virtual ~ClientConnect();

  ClientConnect(const ClientConnect& from);

  inline ClientConnect& operator=(const ClientConnect& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientConnect(ClientConnect&& from) noexcept
    : ClientConnect() {
    *this = ::std::move(from);
  }

  inline ClientConnect& operator=(ClientConnect&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientConnect& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientConnect* internal_default_instance() {
    return reinterpret_cast<const ClientConnect*>(
               &_ClientConnect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ClientConnect* other);
  friend void swap(ClientConnect& a, ClientConnect& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientConnect* New() const final {
    return CreateMaybeMessage<ClientConnect>(NULL);
  }

  ClientConnect* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientConnect>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientConnect& from);
  void MergeFrom(const ClientConnect& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientConnect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string username = 1;
  bool has_username() const;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional string ip = 2;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 2;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // @@protoc_insertion_point(class_scope:protocol.ClientConnect)
 private:
  void set_has_username();
  void clear_has_username();
  void set_has_ip();
  void clear_has_ip();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoomsToJoin : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.RoomsToJoin) */ {
 public:
  RoomsToJoin();
  virtual ~RoomsToJoin();

  RoomsToJoin(const RoomsToJoin& from);

  inline RoomsToJoin& operator=(const RoomsToJoin& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoomsToJoin(RoomsToJoin&& from) noexcept
    : RoomsToJoin() {
    *this = ::std::move(from);
  }

  inline RoomsToJoin& operator=(RoomsToJoin&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomsToJoin& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoomsToJoin* internal_default_instance() {
    return reinterpret_cast<const RoomsToJoin*>(
               &_RoomsToJoin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RoomsToJoin* other);
  friend void swap(RoomsToJoin& a, RoomsToJoin& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoomsToJoin* New() const final {
    return CreateMaybeMessage<RoomsToJoin>(NULL);
  }

  RoomsToJoin* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoomsToJoin>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoomsToJoin& from);
  void MergeFrom(const RoomsToJoin& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomsToJoin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string rooms = 1;
  bool has_rooms() const;
  void clear_rooms();
  static const int kRoomsFieldNumber = 1;
  const ::std::string& rooms() const;
  void set_rooms(const ::std::string& value);
  #if LANG_CXX11
  void set_rooms(::std::string&& value);
  #endif
  void set_rooms(const char* value);
  void set_rooms(const char* value, size_t size);
  ::std::string* mutable_rooms();
  ::std::string* release_rooms();
  void set_allocated_rooms(::std::string* rooms);

  // required string roomsJoin = 2;
  bool has_roomsjoin() const;
  void clear_roomsjoin();
  static const int kRoomsJoinFieldNumber = 2;
  const ::std::string& roomsjoin() const;
  void set_roomsjoin(const ::std::string& value);
  #if LANG_CXX11
  void set_roomsjoin(::std::string&& value);
  #endif
  void set_roomsjoin(const char* value);
  void set_roomsjoin(const char* value, size_t size);
  ::std::string* mutable_roomsjoin();
  ::std::string* release_roomsjoin();
  void set_allocated_roomsjoin(::std::string* roomsjoin);

  // @@protoc_insertion_point(class_scope:protocol.RoomsToJoin)
 private:
  void set_has_rooms();
  void clear_has_rooms();
  void set_has_roomsjoin();
  void clear_has_roomsjoin();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr rooms_;
  ::google::protobuf::internal::ArenaStringPtr roomsjoin_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class JoinRoom : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.JoinRoom) */ {
 public:
  JoinRoom();
  virtual ~JoinRoom();

  JoinRoom(const JoinRoom& from);

  inline JoinRoom& operator=(const JoinRoom& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JoinRoom(JoinRoom&& from) noexcept
    : JoinRoom() {
    *this = ::std::move(from);
  }

  inline JoinRoom& operator=(JoinRoom&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinRoom& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JoinRoom* internal_default_instance() {
    return reinterpret_cast<const JoinRoom*>(
               &_JoinRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(JoinRoom* other);
  friend void swap(JoinRoom& a, JoinRoom& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JoinRoom* New() const final {
    return CreateMaybeMessage<JoinRoom>(NULL);
  }

  JoinRoom* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JoinRoom>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const JoinRoom& from);
  void MergeFrom(const JoinRoom& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinRoom* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 room = 1;
  bool has_room() const;
  void clear_room();
  static const int kRoomFieldNumber = 1;
  ::google::protobuf::int32 room() const;
  void set_room(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.JoinRoom)
 private:
  void set_has_room();
  void clear_has_room();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 room_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoomMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.RoomMessage) */ {
 public:
  RoomMessage();
  virtual ~RoomMessage();

  RoomMessage(const RoomMessage& from);

  inline RoomMessage& operator=(const RoomMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoomMessage(RoomMessage&& from) noexcept
    : RoomMessage() {
    *this = ::std::move(from);
  }

  inline RoomMessage& operator=(RoomMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoomMessage* internal_default_instance() {
    return reinterpret_cast<const RoomMessage*>(
               &_RoomMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(RoomMessage* other);
  friend void swap(RoomMessage& a, RoomMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoomMessage* New() const final {
    return CreateMaybeMessage<RoomMessage>(NULL);
  }

  RoomMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoomMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoomMessage& from);
  void MergeFrom(const RoomMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string message = 1;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:protocol.RoomMessage)
 private:
  void set_has_message();
  void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MatchStart : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.MatchStart) */ {
 public:
  MatchStart();
  virtual ~MatchStart();

  MatchStart(const MatchStart& from);

  inline MatchStart& operator=(const MatchStart& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MatchStart(MatchStart&& from) noexcept
    : MatchStart() {
    *this = ::std::move(from);
  }

  inline MatchStart& operator=(MatchStart&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchStart& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MatchStart* internal_default_instance() {
    return reinterpret_cast<const MatchStart*>(
               &_MatchStart_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(MatchStart* other);
  friend void swap(MatchStart& a, MatchStart& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MatchStart* New() const final {
    return CreateMaybeMessage<MatchStart>(NULL);
  }

  MatchStart* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MatchStart>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MatchStart& from);
  void MergeFrom(const MatchStart& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchStart* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string cards = 1;
  bool has_cards() const;
  void clear_cards();
  static const int kCardsFieldNumber = 1;
  const ::std::string& cards() const;
  void set_cards(const ::std::string& value);
  #if LANG_CXX11
  void set_cards(::std::string&& value);
  #endif
  void set_cards(const char* value);
  void set_cards(const char* value, size_t size);
  ::std::string* mutable_cards();
  ::std::string* release_cards();
  void set_allocated_cards(::std::string* cards);

  // @@protoc_insertion_point(class_scope:protocol.MatchStart)
 private:
  void set_has_cards();
  void clear_has_cards();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr cards_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NewTurn : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.NewTurn) */ {
 public:
  NewTurn();
  virtual ~NewTurn();

  NewTurn(const NewTurn& from);

  inline NewTurn& operator=(const NewTurn& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NewTurn(NewTurn&& from) noexcept
    : NewTurn() {
    *this = ::std::move(from);
  }

  inline NewTurn& operator=(NewTurn&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewTurn& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewTurn* internal_default_instance() {
    return reinterpret_cast<const NewTurn*>(
               &_NewTurn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(NewTurn* other);
  friend void swap(NewTurn& a, NewTurn& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NewTurn* New() const final {
    return CreateMaybeMessage<NewTurn>(NULL);
  }

  NewTurn* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NewTurn>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NewTurn& from);
  void MergeFrom(const NewTurn& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewTurn* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string newCard = 1;
  bool has_newcard() const;
  void clear_newcard();
  static const int kNewCardFieldNumber = 1;
  const ::std::string& newcard() const;
  void set_newcard(const ::std::string& value);
  #if LANG_CXX11
  void set_newcard(::std::string&& value);
  #endif
  void set_newcard(const char* value);
  void set_newcard(const char* value, size_t size);
  ::std::string* mutable_newcard();
  ::std::string* release_newcard();
  void set_allocated_newcard(::std::string* newcard);

  // optional int32 roomCounter = 2;
  bool has_roomcounter() const;
  void clear_roomcounter();
  static const int kRoomCounterFieldNumber = 2;
  ::google::protobuf::int32 roomcounter() const;
  void set_roomcounter(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.NewTurn)
 private:
  void set_has_newcard();
  void clear_has_newcard();
  void set_has_roomcounter();
  void clear_has_roomcounter();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr newcard_;
  ::google::protobuf::int32 roomcounter_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SendCard : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.SendCard) */ {
 public:
  SendCard();
  virtual ~SendCard();

  SendCard(const SendCard& from);

  inline SendCard& operator=(const SendCard& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SendCard(SendCard&& from) noexcept
    : SendCard() {
    *this = ::std::move(from);
  }

  inline SendCard& operator=(SendCard&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SendCard& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SendCard* internal_default_instance() {
    return reinterpret_cast<const SendCard*>(
               &_SendCard_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(SendCard* other);
  friend void swap(SendCard& a, SendCard& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SendCard* New() const final {
    return CreateMaybeMessage<SendCard>(NULL);
  }

  SendCard* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SendCard>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SendCard& from);
  void MergeFrom(const SendCard& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendCard* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string card = 1;
  bool has_card() const;
  void clear_card();
  static const int kCardFieldNumber = 1;
  const ::std::string& card() const;
  void set_card(const ::std::string& value);
  #if LANG_CXX11
  void set_card(::std::string&& value);
  #endif
  void set_card(const char* value);
  void set_card(const char* value, size_t size);
  ::std::string* mutable_card();
  ::std::string* release_card();
  void set_allocated_card(::std::string* card);

  // optional int32 extra = 2;
  bool has_extra() const;
  void clear_extra();
  static const int kExtraFieldNumber = 2;
  ::google::protobuf::int32 extra() const;
  void set_extra(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.SendCard)
 private:
  void set_has_card();
  void clear_has_card();
  void set_has_extra();
  void clear_has_extra();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr card_;
  ::google::protobuf::int32 extra_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ErrorResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.ErrorResponse) */ {
 public:
  ErrorResponse();
  virtual ~ErrorResponse();

  ErrorResponse(const ErrorResponse& from);

  inline ErrorResponse& operator=(const ErrorResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ErrorResponse(ErrorResponse&& from) noexcept
    : ErrorResponse() {
    *this = ::std::move(from);
  }

  inline ErrorResponse& operator=(ErrorResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ErrorResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ErrorResponse* internal_default_instance() {
    return reinterpret_cast<const ErrorResponse*>(
               &_ErrorResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ErrorResponse* other);
  friend void swap(ErrorResponse& a, ErrorResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ErrorResponse* New() const final {
    return CreateMaybeMessage<ErrorResponse>(NULL);
  }

  ErrorResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ErrorResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ErrorResponse& from);
  void MergeFrom(const ErrorResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ErrorResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string errorMessage = 1;
  bool has_errormessage() const;
  void clear_errormessage();
  static const int kErrorMessageFieldNumber = 1;
  const ::std::string& errormessage() const;
  void set_errormessage(const ::std::string& value);
  #if LANG_CXX11
  void set_errormessage(::std::string&& value);
  #endif
  void set_errormessage(const char* value);
  void set_errormessage(const char* value, size_t size);
  ::std::string* mutable_errormessage();
  ::std::string* release_errormessage();
  void set_allocated_errormessage(::std::string* errormessage);

  // @@protoc_insertion_point(class_scope:protocol.ErrorResponse)
 private:
  void set_has_errormessage();
  void clear_has_errormessage();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr errormessage_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Notification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Notification) */ {
 public:
  Notification();
  virtual ~Notification();

  Notification(const Notification& from);

  inline Notification& operator=(const Notification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Notification(Notification&& from) noexcept
    : Notification() {
    *this = ::std::move(from);
  }

  inline Notification& operator=(Notification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Notification& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Notification* internal_default_instance() {
    return reinterpret_cast<const Notification*>(
               &_Notification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Notification* other);
  friend void swap(Notification& a, Notification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Notification* New() const final {
    return CreateMaybeMessage<Notification>(NULL);
  }

  Notification* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Notification>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Notification& from);
  void MergeFrom(const Notification& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Notification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string notiMessage = 1;
  bool has_notimessage() const;
  void clear_notimessage();
  static const int kNotiMessageFieldNumber = 1;
  const ::std::string& notimessage() const;
  void set_notimessage(const ::std::string& value);
  #if LANG_CXX11
  void set_notimessage(::std::string&& value);
  #endif
  void set_notimessage(const char* value);
  void set_notimessage(const char* value, size_t size);
  ::std::string* mutable_notimessage();
  ::std::string* release_notimessage();
  void set_allocated_notimessage(::std::string* notimessage);

  // @@protoc_insertion_point(class_scope:protocol.Notification)
 private:
  void set_has_notimessage();
  void clear_has_notimessage();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr notimessage_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.ClientMessage) */ {
 public:
  ClientMessage();
  virtual ~ClientMessage();

  ClientMessage(const ClientMessage& from);

  inline ClientMessage& operator=(const ClientMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientMessage(ClientMessage&& from) noexcept
    : ClientMessage() {
    *this = ::std::move(from);
  }

  inline ClientMessage& operator=(ClientMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientMessage* internal_default_instance() {
    return reinterpret_cast<const ClientMessage*>(
               &_ClientMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ClientMessage* other);
  friend void swap(ClientMessage& a, ClientMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientMessage* New() const final {
    return CreateMaybeMessage<ClientMessage>(NULL);
  }

  ClientMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientMessage& from);
  void MergeFrom(const ClientMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protocol.ClientConnect connect = 3;
  bool has_connect() const;
  void clear_connect();
  static const int kConnectFieldNumber = 3;
  private:
  const ::protocol::ClientConnect& _internal_connect() const;
  public:
  const ::protocol::ClientConnect& connect() const;
  ::protocol::ClientConnect* release_connect();
  ::protocol::ClientConnect* mutable_connect();
  void set_allocated_connect(::protocol::ClientConnect* connect);

  // optional .protocol.JoinRoom roomJoin = 4;
  bool has_roomjoin() const;
  void clear_roomjoin();
  static const int kRoomJoinFieldNumber = 4;
  private:
  const ::protocol::JoinRoom& _internal_roomjoin() const;
  public:
  const ::protocol::JoinRoom& roomjoin() const;
  ::protocol::JoinRoom* release_roomjoin();
  ::protocol::JoinRoom* mutable_roomjoin();
  void set_allocated_roomjoin(::protocol::JoinRoom* roomjoin);

  // optional .protocol.RoomMessage msgRoom = 5;
  bool has_msgroom() const;
  void clear_msgroom();
  static const int kMsgRoomFieldNumber = 5;
  private:
  const ::protocol::RoomMessage& _internal_msgroom() const;
  public:
  const ::protocol::RoomMessage& msgroom() const;
  ::protocol::RoomMessage* release_msgroom();
  ::protocol::RoomMessage* mutable_msgroom();
  void set_allocated_msgroom(::protocol::RoomMessage* msgroom);

  // optional .protocol.SendCard card = 6;
  bool has_card() const;
  void clear_card();
  static const int kCardFieldNumber = 6;
  private:
  const ::protocol::SendCard& _internal_card() const;
  public:
  const ::protocol::SendCard& card() const;
  ::protocol::SendCard* release_card();
  ::protocol::SendCard* mutable_card();
  void set_allocated_card(::protocol::SendCard* card);

  // required int32 option = 1;
  bool has_option() const;
  void clear_option();
  static const int kOptionFieldNumber = 1;
  ::google::protobuf::int32 option() const;
  void set_option(::google::protobuf::int32 value);

  // optional int32 userId = 2;
  bool has_userid() const;
  void clear_userid();
  static const int kUserIdFieldNumber = 2;
  ::google::protobuf::int32 userid() const;
  void set_userid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.ClientMessage)
 private:
  void set_has_option();
  void clear_has_option();
  void set_has_userid();
  void clear_has_userid();
  void set_has_connect();
  void clear_has_connect();
  void set_has_roomjoin();
  void clear_has_roomjoin();
  void set_has_msgroom();
  void clear_has_msgroom();
  void set_has_card();
  void clear_has_card();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::protocol::ClientConnect* connect_;
  ::protocol::JoinRoom* roomjoin_;
  ::protocol::RoomMessage* msgroom_;
  ::protocol::SendCard* card_;
  ::google::protobuf::int32 option_;
  ::google::protobuf::int32 userid_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServerMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.ServerMessage) */ {
 public:
  ServerMessage();
  virtual ~ServerMessage();

  ServerMessage(const ServerMessage& from);

  inline ServerMessage& operator=(const ServerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerMessage(ServerMessage&& from) noexcept
    : ServerMessage() {
    *this = ::std::move(from);
  }

  inline ServerMessage& operator=(ServerMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerMessage* internal_default_instance() {
    return reinterpret_cast<const ServerMessage*>(
               &_ServerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(ServerMessage* other);
  friend void swap(ServerMessage& a, ServerMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerMessage* New() const final {
    return CreateMaybeMessage<ServerMessage>(NULL);
  }

  ServerMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServerMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServerMessage& from);
  void MergeFrom(const ServerMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protocol.RoomsToJoin rooms = 2;
  bool has_rooms() const;
  void clear_rooms();
  static const int kRoomsFieldNumber = 2;
  private:
  const ::protocol::RoomsToJoin& _internal_rooms() const;
  public:
  const ::protocol::RoomsToJoin& rooms() const;
  ::protocol::RoomsToJoin* release_rooms();
  ::protocol::RoomsToJoin* mutable_rooms();
  void set_allocated_rooms(::protocol::RoomsToJoin* rooms);

  // optional .protocol.ErrorResponse error = 3;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 3;
  private:
  const ::protocol::ErrorResponse& _internal_error() const;
  public:
  const ::protocol::ErrorResponse& error() const;
  ::protocol::ErrorResponse* release_error();
  ::protocol::ErrorResponse* mutable_error();
  void set_allocated_error(::protocol::ErrorResponse* error);

  // optional .protocol.Notification noti = 4;
  bool has_noti() const;
  void clear_noti();
  static const int kNotiFieldNumber = 4;
  private:
  const ::protocol::Notification& _internal_noti() const;
  public:
  const ::protocol::Notification& noti() const;
  ::protocol::Notification* release_noti();
  ::protocol::Notification* mutable_noti();
  void set_allocated_noti(::protocol::Notification* noti);

  // optional .protocol.MatchStart start = 5;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 5;
  private:
  const ::protocol::MatchStart& _internal_start() const;
  public:
  const ::protocol::MatchStart& start() const;
  ::protocol::MatchStart* release_start();
  ::protocol::MatchStart* mutable_start();
  void set_allocated_start(::protocol::MatchStart* start);

  // optional .protocol.NewTurn turn = 6;
  bool has_turn() const;
  void clear_turn();
  static const int kTurnFieldNumber = 6;
  private:
  const ::protocol::NewTurn& _internal_turn() const;
  public:
  const ::protocol::NewTurn& turn() const;
  ::protocol::NewTurn* release_turn();
  ::protocol::NewTurn* mutable_turn();
  void set_allocated_turn(::protocol::NewTurn* turn);

  // required int32 option = 1;
  bool has_option() const;
  void clear_option();
  static const int kOptionFieldNumber = 1;
  ::google::protobuf::int32 option() const;
  void set_option(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.ServerMessage)
 private:
  void set_has_option();
  void clear_has_option();
  void set_has_rooms();
  void clear_has_rooms();
  void set_has_error();
  void clear_has_error();
  void set_has_noti();
  void clear_has_noti();
  void set_has_start();
  void clear_has_start();
  void set_has_turn();
  void clear_has_turn();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::protocol::RoomsToJoin* rooms_;
  ::protocol::ErrorResponse* error_;
  ::protocol::Notification* noti_;
  ::protocol::MatchStart* start_;
  ::protocol::NewTurn* turn_;
  ::google::protobuf::int32 option_;
  friend struct ::protobuf_protocol_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ClientConnect

// required string username = 1;
inline bool ClientConnect::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientConnect::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientConnect::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientConnect::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& ClientConnect::username() const {
  // @@protoc_insertion_point(field_get:protocol.ClientConnect.username)
  return username_.GetNoArena();
}
inline void ClientConnect::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.ClientConnect.username)
}
#if LANG_CXX11
inline void ClientConnect::set_username(::std::string&& value) {
  set_has_username();
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.ClientConnect.username)
}
#endif
inline void ClientConnect::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.ClientConnect.username)
}
inline void ClientConnect::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.ClientConnect.username)
}
inline ::std::string* ClientConnect::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:protocol.ClientConnect.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientConnect::release_username() {
  // @@protoc_insertion_point(field_release:protocol.ClientConnect.username)
  if (!has_username()) {
    return NULL;
  }
  clear_has_username();
  return username_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientConnect::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:protocol.ClientConnect.username)
}

// optional string ip = 2;
inline bool ClientConnect::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientConnect::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientConnect::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientConnect::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip();
}
inline const ::std::string& ClientConnect::ip() const {
  // @@protoc_insertion_point(field_get:protocol.ClientConnect.ip)
  return ip_.GetNoArena();
}
inline void ClientConnect::set_ip(const ::std::string& value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.ClientConnect.ip)
}
#if LANG_CXX11
inline void ClientConnect::set_ip(::std::string&& value) {
  set_has_ip();
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.ClientConnect.ip)
}
#endif
inline void ClientConnect::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.ClientConnect.ip)
}
inline void ClientConnect::set_ip(const char* value, size_t size) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.ClientConnect.ip)
}
inline ::std::string* ClientConnect::mutable_ip() {
  set_has_ip();
  // @@protoc_insertion_point(field_mutable:protocol.ClientConnect.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientConnect::release_ip() {
  // @@protoc_insertion_point(field_release:protocol.ClientConnect.ip)
  if (!has_ip()) {
    return NULL;
  }
  clear_has_ip();
  return ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientConnect::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    set_has_ip();
  } else {
    clear_has_ip();
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:protocol.ClientConnect.ip)
}

// -------------------------------------------------------------------

// RoomsToJoin

// required string rooms = 1;
inline bool RoomsToJoin::has_rooms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomsToJoin::set_has_rooms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomsToJoin::clear_has_rooms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomsToJoin::clear_rooms() {
  rooms_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_rooms();
}
inline const ::std::string& RoomsToJoin::rooms() const {
  // @@protoc_insertion_point(field_get:protocol.RoomsToJoin.rooms)
  return rooms_.GetNoArena();
}
inline void RoomsToJoin::set_rooms(const ::std::string& value) {
  set_has_rooms();
  rooms_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.RoomsToJoin.rooms)
}
#if LANG_CXX11
inline void RoomsToJoin::set_rooms(::std::string&& value) {
  set_has_rooms();
  rooms_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.RoomsToJoin.rooms)
}
#endif
inline void RoomsToJoin::set_rooms(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_rooms();
  rooms_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.RoomsToJoin.rooms)
}
inline void RoomsToJoin::set_rooms(const char* value, size_t size) {
  set_has_rooms();
  rooms_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.RoomsToJoin.rooms)
}
inline ::std::string* RoomsToJoin::mutable_rooms() {
  set_has_rooms();
  // @@protoc_insertion_point(field_mutable:protocol.RoomsToJoin.rooms)
  return rooms_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoomsToJoin::release_rooms() {
  // @@protoc_insertion_point(field_release:protocol.RoomsToJoin.rooms)
  if (!has_rooms()) {
    return NULL;
  }
  clear_has_rooms();
  return rooms_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoomsToJoin::set_allocated_rooms(::std::string* rooms) {
  if (rooms != NULL) {
    set_has_rooms();
  } else {
    clear_has_rooms();
  }
  rooms_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), rooms);
  // @@protoc_insertion_point(field_set_allocated:protocol.RoomsToJoin.rooms)
}

// required string roomsJoin = 2;
inline bool RoomsToJoin::has_roomsjoin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomsToJoin::set_has_roomsjoin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomsToJoin::clear_has_roomsjoin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomsToJoin::clear_roomsjoin() {
  roomsjoin_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_roomsjoin();
}
inline const ::std::string& RoomsToJoin::roomsjoin() const {
  // @@protoc_insertion_point(field_get:protocol.RoomsToJoin.roomsJoin)
  return roomsjoin_.GetNoArena();
}
inline void RoomsToJoin::set_roomsjoin(const ::std::string& value) {
  set_has_roomsjoin();
  roomsjoin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.RoomsToJoin.roomsJoin)
}
#if LANG_CXX11
inline void RoomsToJoin::set_roomsjoin(::std::string&& value) {
  set_has_roomsjoin();
  roomsjoin_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.RoomsToJoin.roomsJoin)
}
#endif
inline void RoomsToJoin::set_roomsjoin(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_roomsjoin();
  roomsjoin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.RoomsToJoin.roomsJoin)
}
inline void RoomsToJoin::set_roomsjoin(const char* value, size_t size) {
  set_has_roomsjoin();
  roomsjoin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.RoomsToJoin.roomsJoin)
}
inline ::std::string* RoomsToJoin::mutable_roomsjoin() {
  set_has_roomsjoin();
  // @@protoc_insertion_point(field_mutable:protocol.RoomsToJoin.roomsJoin)
  return roomsjoin_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoomsToJoin::release_roomsjoin() {
  // @@protoc_insertion_point(field_release:protocol.RoomsToJoin.roomsJoin)
  if (!has_roomsjoin()) {
    return NULL;
  }
  clear_has_roomsjoin();
  return roomsjoin_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoomsToJoin::set_allocated_roomsjoin(::std::string* roomsjoin) {
  if (roomsjoin != NULL) {
    set_has_roomsjoin();
  } else {
    clear_has_roomsjoin();
  }
  roomsjoin_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), roomsjoin);
  // @@protoc_insertion_point(field_set_allocated:protocol.RoomsToJoin.roomsJoin)
}

// -------------------------------------------------------------------

// JoinRoom

// required int32 room = 1;
inline bool JoinRoom::has_room() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JoinRoom::set_has_room() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JoinRoom::clear_has_room() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JoinRoom::clear_room() {
  room_ = 0;
  clear_has_room();
}
inline ::google::protobuf::int32 JoinRoom::room() const {
  // @@protoc_insertion_point(field_get:protocol.JoinRoom.room)
  return room_;
}
inline void JoinRoom::set_room(::google::protobuf::int32 value) {
  set_has_room();
  room_ = value;
  // @@protoc_insertion_point(field_set:protocol.JoinRoom.room)
}

// -------------------------------------------------------------------

// RoomMessage

// required string message = 1;
inline bool RoomMessage::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomMessage::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& RoomMessage::message() const {
  // @@protoc_insertion_point(field_get:protocol.RoomMessage.message)
  return message_.GetNoArena();
}
inline void RoomMessage::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.RoomMessage.message)
}
#if LANG_CXX11
inline void RoomMessage::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.RoomMessage.message)
}
#endif
inline void RoomMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.RoomMessage.message)
}
inline void RoomMessage::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.RoomMessage.message)
}
inline ::std::string* RoomMessage::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:protocol.RoomMessage.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoomMessage::release_message() {
  // @@protoc_insertion_point(field_release:protocol.RoomMessage.message)
  if (!has_message()) {
    return NULL;
  }
  clear_has_message();
  return message_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoomMessage::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:protocol.RoomMessage.message)
}

// -------------------------------------------------------------------

// MatchStart

// required string cards = 1;
inline bool MatchStart::has_cards() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MatchStart::set_has_cards() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MatchStart::clear_has_cards() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MatchStart::clear_cards() {
  cards_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_cards();
}
inline const ::std::string& MatchStart::cards() const {
  // @@protoc_insertion_point(field_get:protocol.MatchStart.cards)
  return cards_.GetNoArena();
}
inline void MatchStart::set_cards(const ::std::string& value) {
  set_has_cards();
  cards_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.MatchStart.cards)
}
#if LANG_CXX11
inline void MatchStart::set_cards(::std::string&& value) {
  set_has_cards();
  cards_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.MatchStart.cards)
}
#endif
inline void MatchStart::set_cards(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_cards();
  cards_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.MatchStart.cards)
}
inline void MatchStart::set_cards(const char* value, size_t size) {
  set_has_cards();
  cards_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.MatchStart.cards)
}
inline ::std::string* MatchStart::mutable_cards() {
  set_has_cards();
  // @@protoc_insertion_point(field_mutable:protocol.MatchStart.cards)
  return cards_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MatchStart::release_cards() {
  // @@protoc_insertion_point(field_release:protocol.MatchStart.cards)
  if (!has_cards()) {
    return NULL;
  }
  clear_has_cards();
  return cards_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MatchStart::set_allocated_cards(::std::string* cards) {
  if (cards != NULL) {
    set_has_cards();
  } else {
    clear_has_cards();
  }
  cards_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cards);
  // @@protoc_insertion_point(field_set_allocated:protocol.MatchStart.cards)
}

// -------------------------------------------------------------------

// NewTurn

// required string newCard = 1;
inline bool NewTurn::has_newcard() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewTurn::set_has_newcard() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewTurn::clear_has_newcard() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewTurn::clear_newcard() {
  newcard_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_newcard();
}
inline const ::std::string& NewTurn::newcard() const {
  // @@protoc_insertion_point(field_get:protocol.NewTurn.newCard)
  return newcard_.GetNoArena();
}
inline void NewTurn::set_newcard(const ::std::string& value) {
  set_has_newcard();
  newcard_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.NewTurn.newCard)
}
#if LANG_CXX11
inline void NewTurn::set_newcard(::std::string&& value) {
  set_has_newcard();
  newcard_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.NewTurn.newCard)
}
#endif
inline void NewTurn::set_newcard(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_newcard();
  newcard_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.NewTurn.newCard)
}
inline void NewTurn::set_newcard(const char* value, size_t size) {
  set_has_newcard();
  newcard_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.NewTurn.newCard)
}
inline ::std::string* NewTurn::mutable_newcard() {
  set_has_newcard();
  // @@protoc_insertion_point(field_mutable:protocol.NewTurn.newCard)
  return newcard_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewTurn::release_newcard() {
  // @@protoc_insertion_point(field_release:protocol.NewTurn.newCard)
  if (!has_newcard()) {
    return NULL;
  }
  clear_has_newcard();
  return newcard_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewTurn::set_allocated_newcard(::std::string* newcard) {
  if (newcard != NULL) {
    set_has_newcard();
  } else {
    clear_has_newcard();
  }
  newcard_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), newcard);
  // @@protoc_insertion_point(field_set_allocated:protocol.NewTurn.newCard)
}

// optional int32 roomCounter = 2;
inline bool NewTurn::has_roomcounter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewTurn::set_has_roomcounter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewTurn::clear_has_roomcounter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewTurn::clear_roomcounter() {
  roomcounter_ = 0;
  clear_has_roomcounter();
}
inline ::google::protobuf::int32 NewTurn::roomcounter() const {
  // @@protoc_insertion_point(field_get:protocol.NewTurn.roomCounter)
  return roomcounter_;
}
inline void NewTurn::set_roomcounter(::google::protobuf::int32 value) {
  set_has_roomcounter();
  roomcounter_ = value;
  // @@protoc_insertion_point(field_set:protocol.NewTurn.roomCounter)
}

// -------------------------------------------------------------------

// SendCard

// required string card = 1;
inline bool SendCard::has_card() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendCard::set_has_card() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendCard::clear_has_card() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendCard::clear_card() {
  card_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_card();
}
inline const ::std::string& SendCard::card() const {
  // @@protoc_insertion_point(field_get:protocol.SendCard.card)
  return card_.GetNoArena();
}
inline void SendCard::set_card(const ::std::string& value) {
  set_has_card();
  card_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.SendCard.card)
}
#if LANG_CXX11
inline void SendCard::set_card(::std::string&& value) {
  set_has_card();
  card_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.SendCard.card)
}
#endif
inline void SendCard::set_card(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_card();
  card_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.SendCard.card)
}
inline void SendCard::set_card(const char* value, size_t size) {
  set_has_card();
  card_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.SendCard.card)
}
inline ::std::string* SendCard::mutable_card() {
  set_has_card();
  // @@protoc_insertion_point(field_mutable:protocol.SendCard.card)
  return card_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SendCard::release_card() {
  // @@protoc_insertion_point(field_release:protocol.SendCard.card)
  if (!has_card()) {
    return NULL;
  }
  clear_has_card();
  return card_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SendCard::set_allocated_card(::std::string* card) {
  if (card != NULL) {
    set_has_card();
  } else {
    clear_has_card();
  }
  card_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), card);
  // @@protoc_insertion_point(field_set_allocated:protocol.SendCard.card)
}

// optional int32 extra = 2;
inline bool SendCard::has_extra() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendCard::set_has_extra() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendCard::clear_has_extra() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendCard::clear_extra() {
  extra_ = 0;
  clear_has_extra();
}
inline ::google::protobuf::int32 SendCard::extra() const {
  // @@protoc_insertion_point(field_get:protocol.SendCard.extra)
  return extra_;
}
inline void SendCard::set_extra(::google::protobuf::int32 value) {
  set_has_extra();
  extra_ = value;
  // @@protoc_insertion_point(field_set:protocol.SendCard.extra)
}

// -------------------------------------------------------------------

// ErrorResponse

// required string errorMessage = 1;
inline bool ErrorResponse::has_errormessage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ErrorResponse::set_has_errormessage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ErrorResponse::clear_has_errormessage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ErrorResponse::clear_errormessage() {
  errormessage_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_errormessage();
}
inline const ::std::string& ErrorResponse::errormessage() const {
  // @@protoc_insertion_point(field_get:protocol.ErrorResponse.errorMessage)
  return errormessage_.GetNoArena();
}
inline void ErrorResponse::set_errormessage(const ::std::string& value) {
  set_has_errormessage();
  errormessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.ErrorResponse.errorMessage)
}
#if LANG_CXX11
inline void ErrorResponse::set_errormessage(::std::string&& value) {
  set_has_errormessage();
  errormessage_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.ErrorResponse.errorMessage)
}
#endif
inline void ErrorResponse::set_errormessage(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_errormessage();
  errormessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.ErrorResponse.errorMessage)
}
inline void ErrorResponse::set_errormessage(const char* value, size_t size) {
  set_has_errormessage();
  errormessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.ErrorResponse.errorMessage)
}
inline ::std::string* ErrorResponse::mutable_errormessage() {
  set_has_errormessage();
  // @@protoc_insertion_point(field_mutable:protocol.ErrorResponse.errorMessage)
  return errormessage_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ErrorResponse::release_errormessage() {
  // @@protoc_insertion_point(field_release:protocol.ErrorResponse.errorMessage)
  if (!has_errormessage()) {
    return NULL;
  }
  clear_has_errormessage();
  return errormessage_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ErrorResponse::set_allocated_errormessage(::std::string* errormessage) {
  if (errormessage != NULL) {
    set_has_errormessage();
  } else {
    clear_has_errormessage();
  }
  errormessage_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), errormessage);
  // @@protoc_insertion_point(field_set_allocated:protocol.ErrorResponse.errorMessage)
}

// -------------------------------------------------------------------

// Notification

// required string notiMessage = 1;
inline bool Notification::has_notimessage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Notification::set_has_notimessage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Notification::clear_has_notimessage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Notification::clear_notimessage() {
  notimessage_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_notimessage();
}
inline const ::std::string& Notification::notimessage() const {
  // @@protoc_insertion_point(field_get:protocol.Notification.notiMessage)
  return notimessage_.GetNoArena();
}
inline void Notification::set_notimessage(const ::std::string& value) {
  set_has_notimessage();
  notimessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Notification.notiMessage)
}
#if LANG_CXX11
inline void Notification::set_notimessage(::std::string&& value) {
  set_has_notimessage();
  notimessage_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Notification.notiMessage)
}
#endif
inline void Notification::set_notimessage(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_notimessage();
  notimessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Notification.notiMessage)
}
inline void Notification::set_notimessage(const char* value, size_t size) {
  set_has_notimessage();
  notimessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Notification.notiMessage)
}
inline ::std::string* Notification::mutable_notimessage() {
  set_has_notimessage();
  // @@protoc_insertion_point(field_mutable:protocol.Notification.notiMessage)
  return notimessage_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Notification::release_notimessage() {
  // @@protoc_insertion_point(field_release:protocol.Notification.notiMessage)
  if (!has_notimessage()) {
    return NULL;
  }
  clear_has_notimessage();
  return notimessage_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Notification::set_allocated_notimessage(::std::string* notimessage) {
  if (notimessage != NULL) {
    set_has_notimessage();
  } else {
    clear_has_notimessage();
  }
  notimessage_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), notimessage);
  // @@protoc_insertion_point(field_set_allocated:protocol.Notification.notiMessage)
}

// -------------------------------------------------------------------

// ClientMessage

// required int32 option = 1;
inline bool ClientMessage::has_option() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientMessage::set_has_option() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientMessage::clear_has_option() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientMessage::clear_option() {
  option_ = 0;
  clear_has_option();
}
inline ::google::protobuf::int32 ClientMessage::option() const {
  // @@protoc_insertion_point(field_get:protocol.ClientMessage.option)
  return option_;
}
inline void ClientMessage::set_option(::google::protobuf::int32 value) {
  set_has_option();
  option_ = value;
  // @@protoc_insertion_point(field_set:protocol.ClientMessage.option)
}

// optional int32 userId = 2;
inline bool ClientMessage::has_userid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientMessage::set_has_userid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientMessage::clear_has_userid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientMessage::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 ClientMessage::userid() const {
  // @@protoc_insertion_point(field_get:protocol.ClientMessage.userId)
  return userid_;
}
inline void ClientMessage::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
  // @@protoc_insertion_point(field_set:protocol.ClientMessage.userId)
}

// optional .protocol.ClientConnect connect = 3;
inline bool ClientMessage::has_connect() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientMessage::set_has_connect() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientMessage::clear_has_connect() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientMessage::clear_connect() {
  if (connect_ != NULL) connect_->Clear();
  clear_has_connect();
}
inline const ::protocol::ClientConnect& ClientMessage::_internal_connect() const {
  return *connect_;
}
inline const ::protocol::ClientConnect& ClientMessage::connect() const {
  const ::protocol::ClientConnect* p = connect_;
  // @@protoc_insertion_point(field_get:protocol.ClientMessage.connect)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::ClientConnect*>(
      &::protocol::_ClientConnect_default_instance_);
}
inline ::protocol::ClientConnect* ClientMessage::release_connect() {
  // @@protoc_insertion_point(field_release:protocol.ClientMessage.connect)
  clear_has_connect();
  ::protocol::ClientConnect* temp = connect_;
  connect_ = NULL;
  return temp;
}
inline ::protocol::ClientConnect* ClientMessage::mutable_connect() {
  set_has_connect();
  if (connect_ == NULL) {
    auto* p = CreateMaybeMessage<::protocol::ClientConnect>(GetArenaNoVirtual());
    connect_ = p;
  }
  // @@protoc_insertion_point(field_mutable:protocol.ClientMessage.connect)
  return connect_;
}
inline void ClientMessage::set_allocated_connect(::protocol::ClientConnect* connect) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete connect_;
  }
  if (connect) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      connect = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, connect, submessage_arena);
    }
    set_has_connect();
  } else {
    clear_has_connect();
  }
  connect_ = connect;
  // @@protoc_insertion_point(field_set_allocated:protocol.ClientMessage.connect)
}

// optional .protocol.JoinRoom roomJoin = 4;
inline bool ClientMessage::has_roomjoin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientMessage::set_has_roomjoin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientMessage::clear_has_roomjoin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientMessage::clear_roomjoin() {
  if (roomjoin_ != NULL) roomjoin_->Clear();
  clear_has_roomjoin();
}
inline const ::protocol::JoinRoom& ClientMessage::_internal_roomjoin() const {
  return *roomjoin_;
}
inline const ::protocol::JoinRoom& ClientMessage::roomjoin() const {
  const ::protocol::JoinRoom* p = roomjoin_;
  // @@protoc_insertion_point(field_get:protocol.ClientMessage.roomJoin)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::JoinRoom*>(
      &::protocol::_JoinRoom_default_instance_);
}
inline ::protocol::JoinRoom* ClientMessage::release_roomjoin() {
  // @@protoc_insertion_point(field_release:protocol.ClientMessage.roomJoin)
  clear_has_roomjoin();
  ::protocol::JoinRoom* temp = roomjoin_;
  roomjoin_ = NULL;
  return temp;
}
inline ::protocol::JoinRoom* ClientMessage::mutable_roomjoin() {
  set_has_roomjoin();
  if (roomjoin_ == NULL) {
    auto* p = CreateMaybeMessage<::protocol::JoinRoom>(GetArenaNoVirtual());
    roomjoin_ = p;
  }
  // @@protoc_insertion_point(field_mutable:protocol.ClientMessage.roomJoin)
  return roomjoin_;
}
inline void ClientMessage::set_allocated_roomjoin(::protocol::JoinRoom* roomjoin) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete roomjoin_;
  }
  if (roomjoin) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      roomjoin = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, roomjoin, submessage_arena);
    }
    set_has_roomjoin();
  } else {
    clear_has_roomjoin();
  }
  roomjoin_ = roomjoin;
  // @@protoc_insertion_point(field_set_allocated:protocol.ClientMessage.roomJoin)
}

// optional .protocol.RoomMessage msgRoom = 5;
inline bool ClientMessage::has_msgroom() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientMessage::set_has_msgroom() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientMessage::clear_has_msgroom() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientMessage::clear_msgroom() {
  if (msgroom_ != NULL) msgroom_->Clear();
  clear_has_msgroom();
}
inline const ::protocol::RoomMessage& ClientMessage::_internal_msgroom() const {
  return *msgroom_;
}
inline const ::protocol::RoomMessage& ClientMessage::msgroom() const {
  const ::protocol::RoomMessage* p = msgroom_;
  // @@protoc_insertion_point(field_get:protocol.ClientMessage.msgRoom)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::RoomMessage*>(
      &::protocol::_RoomMessage_default_instance_);
}
inline ::protocol::RoomMessage* ClientMessage::release_msgroom() {
  // @@protoc_insertion_point(field_release:protocol.ClientMessage.msgRoom)
  clear_has_msgroom();
  ::protocol::RoomMessage* temp = msgroom_;
  msgroom_ = NULL;
  return temp;
}
inline ::protocol::RoomMessage* ClientMessage::mutable_msgroom() {
  set_has_msgroom();
  if (msgroom_ == NULL) {
    auto* p = CreateMaybeMessage<::protocol::RoomMessage>(GetArenaNoVirtual());
    msgroom_ = p;
  }
  // @@protoc_insertion_point(field_mutable:protocol.ClientMessage.msgRoom)
  return msgroom_;
}
inline void ClientMessage::set_allocated_msgroom(::protocol::RoomMessage* msgroom) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete msgroom_;
  }
  if (msgroom) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      msgroom = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, msgroom, submessage_arena);
    }
    set_has_msgroom();
  } else {
    clear_has_msgroom();
  }
  msgroom_ = msgroom;
  // @@protoc_insertion_point(field_set_allocated:protocol.ClientMessage.msgRoom)
}

// optional .protocol.SendCard card = 6;
inline bool ClientMessage::has_card() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientMessage::set_has_card() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientMessage::clear_has_card() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientMessage::clear_card() {
  if (card_ != NULL) card_->Clear();
  clear_has_card();
}
inline const ::protocol::SendCard& ClientMessage::_internal_card() const {
  return *card_;
}
inline const ::protocol::SendCard& ClientMessage::card() const {
  const ::protocol::SendCard* p = card_;
  // @@protoc_insertion_point(field_get:protocol.ClientMessage.card)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::SendCard*>(
      &::protocol::_SendCard_default_instance_);
}
inline ::protocol::SendCard* ClientMessage::release_card() {
  // @@protoc_insertion_point(field_release:protocol.ClientMessage.card)
  clear_has_card();
  ::protocol::SendCard* temp = card_;
  card_ = NULL;
  return temp;
}
inline ::protocol::SendCard* ClientMessage::mutable_card() {
  set_has_card();
  if (card_ == NULL) {
    auto* p = CreateMaybeMessage<::protocol::SendCard>(GetArenaNoVirtual());
    card_ = p;
  }
  // @@protoc_insertion_point(field_mutable:protocol.ClientMessage.card)
  return card_;
}
inline void ClientMessage::set_allocated_card(::protocol::SendCard* card) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete card_;
  }
  if (card) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      card = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, card, submessage_arena);
    }
    set_has_card();
  } else {
    clear_has_card();
  }
  card_ = card;
  // @@protoc_insertion_point(field_set_allocated:protocol.ClientMessage.card)
}

// -------------------------------------------------------------------

// ServerMessage

// required int32 option = 1;
inline bool ServerMessage::has_option() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ServerMessage::set_has_option() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ServerMessage::clear_has_option() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ServerMessage::clear_option() {
  option_ = 0;
  clear_has_option();
}
inline ::google::protobuf::int32 ServerMessage::option() const {
  // @@protoc_insertion_point(field_get:protocol.ServerMessage.option)
  return option_;
}
inline void ServerMessage::set_option(::google::protobuf::int32 value) {
  set_has_option();
  option_ = value;
  // @@protoc_insertion_point(field_set:protocol.ServerMessage.option)
}

// optional .protocol.RoomsToJoin rooms = 2;
inline bool ServerMessage::has_rooms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerMessage::set_has_rooms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerMessage::clear_has_rooms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerMessage::clear_rooms() {
  if (rooms_ != NULL) rooms_->Clear();
  clear_has_rooms();
}
inline const ::protocol::RoomsToJoin& ServerMessage::_internal_rooms() const {
  return *rooms_;
}
inline const ::protocol::RoomsToJoin& ServerMessage::rooms() const {
  const ::protocol::RoomsToJoin* p = rooms_;
  // @@protoc_insertion_point(field_get:protocol.ServerMessage.rooms)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::RoomsToJoin*>(
      &::protocol::_RoomsToJoin_default_instance_);
}
inline ::protocol::RoomsToJoin* ServerMessage::release_rooms() {
  // @@protoc_insertion_point(field_release:protocol.ServerMessage.rooms)
  clear_has_rooms();
  ::protocol::RoomsToJoin* temp = rooms_;
  rooms_ = NULL;
  return temp;
}
inline ::protocol::RoomsToJoin* ServerMessage::mutable_rooms() {
  set_has_rooms();
  if (rooms_ == NULL) {
    auto* p = CreateMaybeMessage<::protocol::RoomsToJoin>(GetArenaNoVirtual());
    rooms_ = p;
  }
  // @@protoc_insertion_point(field_mutable:protocol.ServerMessage.rooms)
  return rooms_;
}
inline void ServerMessage::set_allocated_rooms(::protocol::RoomsToJoin* rooms) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rooms_;
  }
  if (rooms) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rooms = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rooms, submessage_arena);
    }
    set_has_rooms();
  } else {
    clear_has_rooms();
  }
  rooms_ = rooms;
  // @@protoc_insertion_point(field_set_allocated:protocol.ServerMessage.rooms)
}

// optional .protocol.ErrorResponse error = 3;
inline bool ServerMessage::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerMessage::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerMessage::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerMessage::clear_error() {
  if (error_ != NULL) error_->Clear();
  clear_has_error();
}
inline const ::protocol::ErrorResponse& ServerMessage::_internal_error() const {
  return *error_;
}
inline const ::protocol::ErrorResponse& ServerMessage::error() const {
  const ::protocol::ErrorResponse* p = error_;
  // @@protoc_insertion_point(field_get:protocol.ServerMessage.error)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::ErrorResponse*>(
      &::protocol::_ErrorResponse_default_instance_);
}
inline ::protocol::ErrorResponse* ServerMessage::release_error() {
  // @@protoc_insertion_point(field_release:protocol.ServerMessage.error)
  clear_has_error();
  ::protocol::ErrorResponse* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::protocol::ErrorResponse* ServerMessage::mutable_error() {
  set_has_error();
  if (error_ == NULL) {
    auto* p = CreateMaybeMessage<::protocol::ErrorResponse>(GetArenaNoVirtual());
    error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:protocol.ServerMessage.error)
  return error_;
}
inline void ServerMessage::set_allocated_error(::protocol::ErrorResponse* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete error_;
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    set_has_error();
  } else {
    clear_has_error();
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:protocol.ServerMessage.error)
}

// optional .protocol.Notification noti = 4;
inline bool ServerMessage::has_noti() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerMessage::set_has_noti() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerMessage::clear_has_noti() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerMessage::clear_noti() {
  if (noti_ != NULL) noti_->Clear();
  clear_has_noti();
}
inline const ::protocol::Notification& ServerMessage::_internal_noti() const {
  return *noti_;
}
inline const ::protocol::Notification& ServerMessage::noti() const {
  const ::protocol::Notification* p = noti_;
  // @@protoc_insertion_point(field_get:protocol.ServerMessage.noti)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::Notification*>(
      &::protocol::_Notification_default_instance_);
}
inline ::protocol::Notification* ServerMessage::release_noti() {
  // @@protoc_insertion_point(field_release:protocol.ServerMessage.noti)
  clear_has_noti();
  ::protocol::Notification* temp = noti_;
  noti_ = NULL;
  return temp;
}
inline ::protocol::Notification* ServerMessage::mutable_noti() {
  set_has_noti();
  if (noti_ == NULL) {
    auto* p = CreateMaybeMessage<::protocol::Notification>(GetArenaNoVirtual());
    noti_ = p;
  }
  // @@protoc_insertion_point(field_mutable:protocol.ServerMessage.noti)
  return noti_;
}
inline void ServerMessage::set_allocated_noti(::protocol::Notification* noti) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete noti_;
  }
  if (noti) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      noti = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, noti, submessage_arena);
    }
    set_has_noti();
  } else {
    clear_has_noti();
  }
  noti_ = noti;
  // @@protoc_insertion_point(field_set_allocated:protocol.ServerMessage.noti)
}

// optional .protocol.MatchStart start = 5;
inline bool ServerMessage::has_start() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerMessage::set_has_start() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerMessage::clear_has_start() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerMessage::clear_start() {
  if (start_ != NULL) start_->Clear();
  clear_has_start();
}
inline const ::protocol::MatchStart& ServerMessage::_internal_start() const {
  return *start_;
}
inline const ::protocol::MatchStart& ServerMessage::start() const {
  const ::protocol::MatchStart* p = start_;
  // @@protoc_insertion_point(field_get:protocol.ServerMessage.start)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::MatchStart*>(
      &::protocol::_MatchStart_default_instance_);
}
inline ::protocol::MatchStart* ServerMessage::release_start() {
  // @@protoc_insertion_point(field_release:protocol.ServerMessage.start)
  clear_has_start();
  ::protocol::MatchStart* temp = start_;
  start_ = NULL;
  return temp;
}
inline ::protocol::MatchStart* ServerMessage::mutable_start() {
  set_has_start();
  if (start_ == NULL) {
    auto* p = CreateMaybeMessage<::protocol::MatchStart>(GetArenaNoVirtual());
    start_ = p;
  }
  // @@protoc_insertion_point(field_mutable:protocol.ServerMessage.start)
  return start_;
}
inline void ServerMessage::set_allocated_start(::protocol::MatchStart* start) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete start_;
  }
  if (start) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      start = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    set_has_start();
  } else {
    clear_has_start();
  }
  start_ = start;
  // @@protoc_insertion_point(field_set_allocated:protocol.ServerMessage.start)
}

// optional .protocol.NewTurn turn = 6;
inline bool ServerMessage::has_turn() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServerMessage::set_has_turn() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ServerMessage::clear_has_turn() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ServerMessage::clear_turn() {
  if (turn_ != NULL) turn_->Clear();
  clear_has_turn();
}
inline const ::protocol::NewTurn& ServerMessage::_internal_turn() const {
  return *turn_;
}
inline const ::protocol::NewTurn& ServerMessage::turn() const {
  const ::protocol::NewTurn* p = turn_;
  // @@protoc_insertion_point(field_get:protocol.ServerMessage.turn)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::NewTurn*>(
      &::protocol::_NewTurn_default_instance_);
}
inline ::protocol::NewTurn* ServerMessage::release_turn() {
  // @@protoc_insertion_point(field_release:protocol.ServerMessage.turn)
  clear_has_turn();
  ::protocol::NewTurn* temp = turn_;
  turn_ = NULL;
  return temp;
}
inline ::protocol::NewTurn* ServerMessage::mutable_turn() {
  set_has_turn();
  if (turn_ == NULL) {
    auto* p = CreateMaybeMessage<::protocol::NewTurn>(GetArenaNoVirtual());
    turn_ = p;
  }
  // @@protoc_insertion_point(field_mutable:protocol.ServerMessage.turn)
  return turn_;
}
inline void ServerMessage::set_allocated_turn(::protocol::NewTurn* turn) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete turn_;
  }
  if (turn) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      turn = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, turn, submessage_arena);
    }
    set_has_turn();
  } else {
    clear_has_turn();
  }
  turn_ = turn;
  // @@protoc_insertion_point(field_set_allocated:protocol.ServerMessage.turn)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_protocol_2eproto
